{
	"compiler": {
		"version": "0.6.2+commit.bacdbe57"
	},
	"language": "Solidity",
	"output": {
		"abi": [
			{
				"inputs": [],
				"stateMutability": "nonpayable",
				"type": "constructor"
			},
			{
				"anonymous": false,
				"inputs": [
					{
						"indexed": true,
						"internalType": "address",
						"name": "_owner",
						"type": "address"
					},
					{
						"indexed": true,
						"internalType": "address",
						"name": "_approved",
						"type": "address"
					},
					{
						"indexed": true,
						"internalType": "uint256",
						"name": "_tokenId",
						"type": "uint256"
					}
				],
				"name": "Approval",
				"type": "event"
			},
			{
				"anonymous": false,
				"inputs": [
					{
						"indexed": true,
						"internalType": "address",
						"name": "_owner",
						"type": "address"
					},
					{
						"indexed": true,
						"internalType": "address",
						"name": "_operator",
						"type": "address"
					},
					{
						"indexed": false,
						"internalType": "bool",
						"name": "_approved",
						"type": "bool"
					}
				],
				"name": "ApprovalForAll",
				"type": "event"
			},
			{
				"anonymous": false,
				"inputs": [
					{
						"indexed": true,
						"internalType": "address",
						"name": "previousOwner",
						"type": "address"
					},
					{
						"indexed": true,
						"internalType": "address",
						"name": "newOwner",
						"type": "address"
					}
				],
				"name": "OwnershipTransferred",
				"type": "event"
			},
			{
				"anonymous": false,
				"inputs": [
					{
						"indexed": true,
						"internalType": "address",
						"name": "_from",
						"type": "address"
					},
					{
						"indexed": true,
						"internalType": "address",
						"name": "_to",
						"type": "address"
					},
					{
						"indexed": true,
						"internalType": "uint256",
						"name": "_tokenId",
						"type": "uint256"
					}
				],
				"name": "Transfer",
				"type": "event"
			},
			{
				"inputs": [],
				"name": "CANNOT_TRANSFER_TO_ZERO_ADDRESS",
				"outputs": [
					{
						"internalType": "string",
						"name": "",
						"type": "string"
					}
				],
				"stateMutability": "view",
				"type": "function"
			},
			{
				"inputs": [],
				"name": "NOT_CURRENT_OWNER",
				"outputs": [
					{
						"internalType": "string",
						"name": "",
						"type": "string"
					}
				],
				"stateMutability": "view",
				"type": "function"
			},
			{
				"inputs": [
					{
						"internalType": "address",
						"name": "_approved",
						"type": "address"
					},
					{
						"internalType": "uint256",
						"name": "_tokenId",
						"type": "uint256"
					}
				],
				"name": "approve",
				"outputs": [],
				"stateMutability": "nonpayable",
				"type": "function"
			},
			{
				"inputs": [
					{
						"internalType": "address",
						"name": "_owner",
						"type": "address"
					}
				],
				"name": "balanceOf",
				"outputs": [
					{
						"internalType": "uint256",
						"name": "",
						"type": "uint256"
					}
				],
				"stateMutability": "view",
				"type": "function"
			},
			{
				"inputs": [
					{
						"internalType": "uint256",
						"name": "_tokenId",
						"type": "uint256"
					}
				],
				"name": "getApproved",
				"outputs": [
					{
						"internalType": "address",
						"name": "",
						"type": "address"
					}
				],
				"stateMutability": "view",
				"type": "function"
			},
			{
				"inputs": [
					{
						"internalType": "address",
						"name": "_owner",
						"type": "address"
					},
					{
						"internalType": "address",
						"name": "_operator",
						"type": "address"
					}
				],
				"name": "isApprovedForAll",
				"outputs": [
					{
						"internalType": "bool",
						"name": "",
						"type": "bool"
					}
				],
				"stateMutability": "view",
				"type": "function"
			},
			{
				"inputs": [
					{
						"internalType": "address",
						"name": "_to",
						"type": "address"
					},
					{
						"internalType": "uint256",
						"name": "_tokenId",
						"type": "uint256"
					},
					{
						"internalType": "string",
						"name": "_uri",
						"type": "string"
					}
				],
				"name": "mint",
				"outputs": [],
				"stateMutability": "nonpayable",
				"type": "function"
			},
			{
				"inputs": [],
				"name": "name",
				"outputs": [
					{
						"internalType": "string",
						"name": "_name",
						"type": "string"
					}
				],
				"stateMutability": "view",
				"type": "function"
			},
			{
				"inputs": [],
				"name": "owner",
				"outputs": [
					{
						"internalType": "address",
						"name": "",
						"type": "address"
					}
				],
				"stateMutability": "view",
				"type": "function"
			},
			{
				"inputs": [
					{
						"internalType": "uint256",
						"name": "_tokenId",
						"type": "uint256"
					}
				],
				"name": "ownerOf",
				"outputs": [
					{
						"internalType": "address",
						"name": "_owner",
						"type": "address"
					}
				],
				"stateMutability": "view",
				"type": "function"
			},
			{
				"inputs": [
					{
						"internalType": "address",
						"name": "_from",
						"type": "address"
					},
					{
						"internalType": "address",
						"name": "_to",
						"type": "address"
					},
					{
						"internalType": "uint256",
						"name": "_tokenId",
						"type": "uint256"
					}
				],
				"name": "safeTransferFrom",
				"outputs": [],
				"stateMutability": "nonpayable",
				"type": "function"
			},
			{
				"inputs": [
					{
						"internalType": "address",
						"name": "_from",
						"type": "address"
					},
					{
						"internalType": "address",
						"name": "_to",
						"type": "address"
					},
					{
						"internalType": "uint256",
						"name": "_tokenId",
						"type": "uint256"
					},
					{
						"internalType": "bytes",
						"name": "_data",
						"type": "bytes"
					}
				],
				"name": "safeTransferFrom",
				"outputs": [],
				"stateMutability": "nonpayable",
				"type": "function"
			},
			{
				"inputs": [
					{
						"internalType": "address",
						"name": "_operator",
						"type": "address"
					},
					{
						"internalType": "bool",
						"name": "_approved",
						"type": "bool"
					}
				],
				"name": "setApprovalForAll",
				"outputs": [],
				"stateMutability": "nonpayable",
				"type": "function"
			},
			{
				"inputs": [
					{
						"internalType": "bytes4",
						"name": "_interfaceID",
						"type": "bytes4"
					}
				],
				"name": "supportsInterface",
				"outputs": [
					{
						"internalType": "bool",
						"name": "",
						"type": "bool"
					}
				],
				"stateMutability": "view",
				"type": "function"
			},
			{
				"inputs": [],
				"name": "symbol",
				"outputs": [
					{
						"internalType": "string",
						"name": "_symbol",
						"type": "string"
					}
				],
				"stateMutability": "view",
				"type": "function"
			},
			{
				"inputs": [
					{
						"internalType": "uint256",
						"name": "_tokenId",
						"type": "uint256"
					}
				],
				"name": "tokenURI",
				"outputs": [
					{
						"internalType": "string",
						"name": "",
						"type": "string"
					}
				],
				"stateMutability": "view",
				"type": "function"
			},
			{
				"inputs": [
					{
						"internalType": "address",
						"name": "_from",
						"type": "address"
					},
					{
						"internalType": "address",
						"name": "_to",
						"type": "address"
					},
					{
						"internalType": "uint256",
						"name": "_tokenId",
						"type": "uint256"
					}
				],
				"name": "transferFrom",
				"outputs": [],
				"stateMutability": "nonpayable",
				"type": "function"
			},
			{
				"inputs": [
					{
						"internalType": "address",
						"name": "_newOwner",
						"type": "address"
					}
				],
				"name": "transferOwnership",
				"outputs": [],
				"stateMutability": "nonpayable",
				"type": "function"
			}
		],
		"devdoc": {
			"details": "This is an example contract implementation of NFToken with metadata extension.",
			"methods": {
				"approve(address,uint256)": {
					"details": "Set or reaffirm the approved address for an NFT. This function can be changed to payable.",
					"params": {
						"_approved": "Address to be approved for the given NFT ID.",
						"_tokenId": "ID of the token to be approved."
					}
				},
				"balanceOf(address)": {
					"details": "Returns the number of NFTs owned by `_owner`. NFTs assigned to the zero address are considered invalid, and this function throws for queries about the zero address.",
					"params": {
						"_owner": "Address for whom to query the balance."
					},
					"returns": {
						"_0": "Balance of _owner."
					}
				},
				"constructor": {
					"details": "Contract constructor. Sets metadata extension `name` and `symbol`."
				},
				"getApproved(uint256)": {
					"details": "Get the approved address for a single NFT.",
					"params": {
						"_tokenId": "ID of the NFT to query the approval of."
					},
					"returns": {
						"_0": "Address that _tokenId is approved for."
					}
				},
				"isApprovedForAll(address,address)": {
					"details": "Checks if `_operator` is an approved operator for `_owner`.",
					"params": {
						"_operator": "The address that acts on behalf of the owner.",
						"_owner": "The address that owns the NFTs."
					},
					"returns": {
						"_0": "True if approved for all, false otherwise."
					}
				},
				"mint(address,uint256,string)": {
					"details": "Mints a new NFT.",
					"params": {
						"_to": "The address that will own the minted NFT.",
						"_tokenId": "of the NFT to be minted by the msg.sender.",
						"_uri": "String representing RFC 3986 URI."
					}
				},
				"name()": {
					"details": "Returns a descriptive name for a collection of NFTokens.",
					"returns": {
						"_name": "Representing name."
					}
				},
				"ownerOf(uint256)": {
					"details": "Returns the address of the owner of the NFT. NFTs assigned to zero address are considered invalid, and queries about them do throw.",
					"params": {
						"_tokenId": "The identifier for an NFT."
					},
					"returns": {
						"_owner": "Address of _tokenId owner."
					}
				},
				"safeTransferFrom(address,address,uint256)": {
					"details": "Transfers the ownership of an NFT from one address to another address. This function can be changed to payable.",
					"params": {
						"_from": "The current owner of the NFT.",
						"_to": "The new owner.",
						"_tokenId": "The NFT to transfer."
					}
				},
				"safeTransferFrom(address,address,uint256,bytes)": {
					"details": "Transfers the ownership of an NFT from one address to another address. This function can be changed to payable.",
					"params": {
						"_data": "Additional data with no specified format, sent in call to `_to`.",
						"_from": "The current owner of the NFT.",
						"_to": "The new owner.",
						"_tokenId": "The NFT to transfer."
					}
				},
				"setApprovalForAll(address,bool)": {
					"details": "Enables or disables approval for a third party (\"operator\") to manage all of `msg.sender`'s assets. It also emits the ApprovalForAll event.",
					"params": {
						"_approved": "True if the operators is approved, false to revoke approval.",
						"_operator": "Address to add to the set of authorized operators."
					}
				},
				"supportsInterface(bytes4)": {
					"details": "Function to check which interfaces are suported by this contract.",
					"params": {
						"_interfaceID": "Id of the interface."
					},
					"returns": {
						"_0": "True if _interfaceID is supported, false otherwise."
					}
				},
				"symbol()": {
					"details": "Returns an abbreviated name for NFTokens.",
					"returns": {
						"_symbol": "Representing symbol."
					}
				},
				"tokenURI(uint256)": {
					"details": "A distinct URI (RFC 3986) for a given NFT.",
					"params": {
						"_tokenId": "Id for which we want uri."
					},
					"returns": {
						"_0": "URI of _tokenId."
					}
				},
				"transferFrom(address,address,uint256)": {
					"details": "Throws unless `msg.sender` is the current owner, an authorized operator, or the approved address for this NFT. Throws if `_from` is not the current owner. Throws if `_to` is the zero address. Throws if `_tokenId` is not a valid NFT. This function can be changed to payable.",
					"params": {
						"_from": "The current owner of the NFT.",
						"_to": "The new owner.",
						"_tokenId": "The NFT to transfer."
					}
				},
				"transferOwnership(address)": {
					"details": "Allows the current owner to transfer control of the contract to a newOwner.",
					"params": {
						"_newOwner": "The address to transfer ownership to."
					}
				}
			}
		},
		"userdoc": {
			"methods": {
				"approve(address,uint256)": {
					"notice": "The zero address indicates there is no approved address. Throws unless `msg.sender` is the current NFT owner, or an authorized operator of the current owner."
				},
				"getApproved(uint256)": {
					"notice": "Throws if `_tokenId` is not a valid NFT."
				},
				"safeTransferFrom(address,address,uint256)": {
					"notice": "This works identically to the other function with an extra data parameter, except this function just sets data to \"\""
				},
				"safeTransferFrom(address,address,uint256,bytes)": {
					"notice": "Throws unless `msg.sender` is the current owner, an authorized operator, or the approved address for this NFT. Throws if `_from` is not the current owner. Throws if `_to` is the zero address. Throws if `_tokenId` is not a valid NFT. When transfer is complete, this function checks if `_to` is a smart contract (code size > 0). If so, it calls `onERC721Received` on `_to` and throws if the return value is not `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`."
				},
				"setApprovalForAll(address,bool)": {
					"notice": "This works even if sender doesn't own any tokens at the time."
				},
				"transferFrom(address,address,uint256)": {
					"notice": "The caller is responsible to confirm that `_to` is capable of receiving NFTs or else they maybe be permanently lost."
				}
			}
		}
	},
	"settings": {
		"compilationTarget": {
			"browser/0xNFT.sol": "MyArtSale"
		},
		"evmVersion": "istanbul",
		"libraries": {},
		"metadata": {
			"bytecodeHash": "ipfs"
		},
		"optimizer": {
			"enabled": false,
			"runs": 200
		},
		"remappings": []
	},
	"sources": {
		"browser/0xNFT.sol": {
			"keccak256": "0xafeb5b498d0133c70f29227be7a02c1e527f7708edf23a11f180e233f2b4bf02",
			"urls": [
				"bzz-raw://233621c2468f5037de22d3bb79876b437fbf0667c261833160219d8142aa1739",
				"dweb:/ipfs/QmRkM2ZQgHLUuxha3L4sgwpn7MB8tAhToZYPU7vrDjsYWu"
			]
		},
		"https://github.com/0xcert/ethereum-erc721/src/contracts/math/safe-math.sol": {
			"keccak256": "0x03a68b8260abfe702a42167b05ac26217c93c887e2a92ab06a149893d01302df",
			"urls": [
				"bzz-raw://1c635c7457129309d36c9a4a060a114cf8babe013e56aee593f4cdafce463890",
				"dweb:/ipfs/QmaUZFqx6K8bybjdtSrkUJFQkzAaf9AzZYizn6ZyjC4jNb"
			]
		},
		"https://github.com/0xcert/ethereum-erc721/src/contracts/ownership/ownable.sol": {
			"keccak256": "0x07b991e988fe5c48e094cdc862b0e979e2d97ca5dbe06f78953dd2a2c47cc9ba",
			"urls": [
				"bzz-raw://d6895f34a7c0a2e593f265fd80409f49a62452ea31b1e90ea5dc49615abd74e8",
				"dweb:/ipfs/QmdGSEzVeDtVYNMsspbVwdeXr3rvywN4Rz7Fpa91b9XBhs"
			]
		},
		"https://github.com/0xcert/ethereum-erc721/src/contracts/tokens/erc721-metadata.sol": {
			"keccak256": "0xe9d1a5eb6eb32d7d7a5b7fe4b9445327db82535ec777fbe6c7a1fc852430c29a",
			"urls": [
				"bzz-raw://9cc351650fa9de4576f58ad296a4ba08cd4d7ed9cf7a6bd3f0c471552573153d",
				"dweb:/ipfs/QmVP5H2HLk64row31NNUQbT94SYdjhCAJ2dcd2fvJdKeKY"
			]
		},
		"https://github.com/0xcert/ethereum-erc721/src/contracts/tokens/erc721-token-receiver.sol": {
			"keccak256": "0xd7fb67125fb77c8d21f62ff1ee389fd10b1aa8eae68725710d2a377664fd7892",
			"urls": [
				"bzz-raw://c367eecf257999db17e27f0be1623def86a9e50ea9c89ee8a4a69a401692fbdb",
				"dweb:/ipfs/QmY5Jeg16wMsWYrH58uT2xmTNLvJey3668eURPb98x2h3M"
			]
		},
		"https://github.com/0xcert/ethereum-erc721/src/contracts/tokens/erc721.sol": {
			"keccak256": "0x2aa58ee300b4509d2fcb5de8f1582f589540c8ebdb069e14102063e76a71bc12",
			"urls": [
				"bzz-raw://161d80d2d97280e751dab30e598ebbfe935865280c583d5ac18a2ff5ab9938ca",
				"dweb:/ipfs/QmUpSFNN6qSuaJyTboqYbkrQphQbThqXm5Ud4inS3mdiHQ"
			]
		},
		"https://github.com/0xcert/ethereum-erc721/src/contracts/tokens/nf-token-metadata.sol": {
			"keccak256": "0x9221bcfb062560ea1a8293b35ec942dec07edbb604d404b08bd3255881d084c9",
			"urls": [
				"bzz-raw://b7f85f38716a947bc8d4d52b497d53fb2a8763de16e8266d747b0370b17e6966",
				"dweb:/ipfs/QmNxdD4yddzGCHymV2D94E6K6MFbDw3awWQDV17ZBNh3oV"
			]
		},
		"https://github.com/0xcert/ethereum-erc721/src/contracts/tokens/nf-token.sol": {
			"keccak256": "0x50e808a0d325cf2ded1b365f439a7f91d076927d89184e4b6e9df00dd741e485",
			"urls": [
				"bzz-raw://9d8abba0979c874b681c35699c51122b9f6daaaf2ee3826c226f9d00f812fa1e",
				"dweb:/ipfs/QmQt15pqtiTDkf9Xx8Y411GmqvADohjzW4BTTP9kWrUqtx"
			]
		},
		"https://github.com/0xcert/ethereum-erc721/src/contracts/utils/address-utils.sol": {
			"keccak256": "0xc76454795b89bb3d8d52ea9b71b3b442f8d9b8935a1e8df1d07b1aebd5e7c4f2",
			"urls": [
				"bzz-raw://c7edb820a8cfc0969bd4ca63659942617f3af3b99e623d68c6712e10ecb9d2d2",
				"dweb:/ipfs/QmUpLDxRHFKRS4oAW2dXYt5n2F4JYC1P9xbeXu4n6kTq9X"
			]
		},
		"https://github.com/0xcert/ethereum-erc721/src/contracts/utils/erc165.sol": {
			"keccak256": "0x27b1eeda591f5533c25857fb9f6a8cb21ace7358a151ffdf0b52011a4fafb761",
			"urls": [
				"bzz-raw://e711c3df544325c72fbbab7b5506668799360ef6a1c89312db1adcb28064acea",
				"dweb:/ipfs/QmcSWFEb239xsVyuSEPAqRVqAcQQPHfGDr1nhG76aLGq3f"
			]
		},
		"https://github.com/0xcert/ethereum-erc721/src/contracts/utils/supports-interface.sol": {
			"keccak256": "0x3102bdb456290485edc37c0d31457252cbd2e777f07817c52243bae69b87014f",
			"urls": [
				"bzz-raw://1dfb9d135307ef8d49225aba19bcb40577f794a49cc54e2606f256bb5d54883f",
				"dweb:/ipfs/QmbhJiZRktUe1wFQRBgx5RiR1TrRhCZS8tAQRMFLxRKhuz"
			]
		}
	},
	"version": 1
}